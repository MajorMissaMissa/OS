I.
## Бабуни на јаже

### 1. Проблем

  Некаде во националниот парк Кругер во Јужна Африка има голем кањон. Двете страни на кањонот ги спојува јаже. Бабуните можат да го преминат кањонот користејќи го јажето. Доколку два бабуни кои одат во спротивни насоки се сретнат тогаш ќе настане борба и двата бабуни ќе паднат од јажето. Јажето може да издржи највеќе пет бабуни во исто време. Ако има повеќе од пет бабуни во даден момент, јажето ќе се скине.
	
### 2. Барања
  Да претпоставиме дека може да ги научиме бабуните да користат семафори. Потребно е да се напише решение за синхронизација кое ќе ги задоволи следниве услови:
  - Откако еден бабун ќе се качи на јажето, тој треба да помине безбедно на другата страна без притоа да се сретне со некој друг бабун од спротивната насока.
  - На јажето во исто време може да има највеќе пет бабуни.
  - Група бабуни кои минуваат во една насока не треба да го спречат минувањето на бабуните од спортивна насока, т.е тие не треба да чекаат бесконечно. (Проблем на изгладнување)
  
	
### 3. Методи
  Да претпоставиме дека кањонот има две страни, лева и десна. Во решението мора да се искористат неколку методи кои ќе ја дефинираат состојбата.
  - `state.leftPassing()` и `state.rightPassing()` методите соодветно, се повикуваат за да се назначи дека јажето моментално ќе го користат само бабуните кои минуваат од соодветната страна. Доколку бабуните од лева страна го започнат нивното минување, првиот бабун од групата е должен да го повика методот `state.leftPassing()`. **Напомена**: Овој метод го повикува само првиот бабун од соодветната страна. Методот се повикува секогаш кога ќе настане промена во насоките на движење.
  - `state.cross(this)` методот се повикува кај секој од бабуните (вклучувајќи го и првиот). Овој метод означува дека бабунот го започнал неговото изминување на јажето.
  - `state.leave(this)` методот се повкува кај секој од бабуните откако бабунот ќе премине на другата страна на каноњот.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
II.
Создавање околина за тестирање решенија на проблемот: „Филозофи кои вечераат“
=============================================================================

Семинарска работа по предметот Оперативни Системи 2013/2014,<br />
Факултет за Информатички Науки и Компјутерско Инженерство

Семинарската работа е изработена од:<br />
Александар Митревски <br />
Гроздан Маџаров
 

1. Опис на проблемот
--------------------

N филозофи седат на кружна маса. Пред секој филозоф се наоѓа порција тестенини. Помеѓу секоја чинија се наоѓа по една вилушка – вкупно има N вилушки бидејќи постојат точно N филозофи. Секој филозоф своето време го поминува во јадење и мислење. За филозофот да може да јаде, потребно е да ги држи двете вилушки кои се наоѓаат до него. Било која вилушка може да биде на масата или во раката на само еден филозоф во било кое време. Може да се смета дека филозофите имаат бесконечно многу храна на своите чинии, а за јадење еден оброк на секој филозоф му е потребно конечно време.

Проблемот се состои во дизајнирање алгоритам кој доколку филозофите го следат ќе овозможи ниту еден филозоф да не изгладне и ќе овозможи максимален број филозофи да јадат истовремено.

2. Решение на проблемот
-----------------------

Во склоп на оваа семинарска работа одбрано е едно од предложените решенија<sup>1</sup> на Edsger Wybe Dijkstra кое тековно е познато како „Resource hierarchy solution“<sup>2</sup>, т.е. решение со формирање на хиерархија на ресурсите. Овој алгоритам гарантира дека нема да дојде до блокада или до изгладнување на било кој филозоф.

Решението се состои од подредување на ресурсите, или во овој случај, вилушките, и воведување на правилото дека филозофите секогаш прво ќе побараат вилушка со помал реден број, а откако ќе ја добијат, ќе побараат вилушка со поголем реден број.

Согледувањето на коректноста на решението може да се направи со пример. Нека N = 5 – пет филозофи седат на кружна маса, а истовремено има и 5 вилушки на масата. Филозофите и вилушките ги означуваме со броеви од 1 до 5 и притоа вилушката со реден број 1 се наоѓа на десната страна на филозофот означен со реден број 1 набљудувано од неговата перспектива. Да претпоставиме дека сите филозофи почнуваат да јадат одеднаш. Филозофот број 1 ја зема вилушката број 1 и чека да ја земе вилушката број 2 кој ја земал филозофот број 2 додека филозофот број 1 ја земал вилушката број 1. Филозофот број 2 чека да ја добие вилушката број 3 која ја земал филозофот број 3, а филозофот број 3 чека да ја добие вилушката број 4 која ја земал филозофот број 4. Благодарение на подредувањето на вилушките, филозофот број 5 нема да посегне по вилушката број 5 бидејќи најпрво му е потребна вилушката со број 1, па тој ќе чека филозофот број 1 да ја остави вилушката број 1 за самиот да може да ја земе пред да ја побара вилушката број 5. Благодарение на овој факт, филозофот број 4 ќе може да ја добие вилушката број 5 и откако ќе заврши со јадењето, ќе ги ослободи двете вилушки, со што филозофот број 3 ќе може веднаш да почне да јаде. На истиот начин, филозофите со броеви 3, 2 и 1 ќе завршат со јадење, по што филозофот број 5 ќе може да ја добие вилушката број 1, а потоа и вилушката број 5.

Забелешка: решението предложено од Andrew Stuart Tanenbaum<sup>3</sup> не е искористено во овој случај поради тоа што не овозможува сигурност дека ниту еден филозоф нема да изгладне.

3. Околина за решавање на проблемот
-----------------------------------

Околината за решавање на проблемот е имплементирана со помош на приложената архитектура од страна на менторот на семинарската работа. Авторите на оваа семинарска работа во склоп со овој документ приложуваат два .java документи со изворен код: `DiningPhilosophers.java` и `DiningPhilosophersState.java`.

**DiningPhilosophers.java**

Оваа класа го имплементира претходно опишаното решение. Јавната класа `DiningPhilosophers` дефинира класа `Philosopher` која претставува филозоф. Класата содржи покажувачи кон вилушките кои му се доделени на филозофот согласно со решението. Пред да земе да јаде, тој прво чека да ја добие вилушката со помал реден број, а потоа онаа со поголем. Откако ќе заврши со јадење и ќе ги остави вилушките, тој почнува да мисли.

Класата `DiningPhilosophers` содржи N семафори кои ги претставуваат вилушките на масата, а секој семафор е поддесен да пропушта само една нишка. `main()` методот во оваа класа го повикува само еднаш `run()` методот од истата класа – доколку има потреба од повторено извршување на циклусот, истото може да се изведе со промена на вредности на одредени променливи во самиот метод:

- `DiningPhilosophers.NUMBER_OF_PHILOSOPHERS` го означува бројот на филозофи кои седат на кружната маса – овој број останува ист за сите итерации доколку важи `step = 0`.
- `numRuns` е бројот на повторувања на `execute()` методот на секој филозоф.
- `numIterations` е бројот на изведувања на целиот алгоритам, т.е. бројот на маси околку кои седат филозофи кои ќе ги набљудуваме.
- `step` е вредноста на зголемувањето на бројот на филозофи кои седат на масата во секоја наредна итерација.

**DiningPhilosophersState.java**

Наведената класа ја имплементира контролната околина во која ќе се изведува настанот, т.е. масата со филозофите. При тестирање на решенија на проблемот „филозофи кои вечераат“ треба да се обрне внимание на појавата на следните настани:

1. Една вилушка се користи истовремено од повеќе од еден филозоф.
2. Блокада: состојба во која секој од филозофите чека некој друг да ослободи вилушка.
3. Изгладнување: барем еден филозоф не може да дојде на ред да ги земе вилушките.
4. Последователност: само еден филозоф јаде во било кој временски момент.

Доколку ниту еден од овие настани не се случи, тогаш решението е коректно.

Најважни методи во оваа класа се методите `eat()` и `think()` кои се повикуваат во `execute()` методот на `DiningPhilosophers.Philosopher` класата:

- `eat()` методот го имплементира процесот на јадење. Најпрво се забележува дека овој филозоф преминал во состојба „јадење“. Се проверува дали некој од соседите на овој филозоф, филзофите лево и десно од него, тековно јаде. Во таков случај се забележува исклучок, бидејќи дошло до појава на настан 1. од горенаведената листа. Се зголемува бројот на филозофи кои тековно јадат и нишката се суспендира одредено време за да се симулира јадење. Бројот на филозофи кои тековно јадат се намалува, а состојбата на филозофот се враќа во „размислување“ откако филозофот ќе заврши со јадење. Се напоменува дека состојбата „размислување“ во овој контекст претставува комплемент на состојбата „јадење“, т.е. филозоф во состојба „размислување“ може да не размислува, туку да чека вилушка за одново да почне да јаде.
- `think()` методот забележува дека филозофот преминал во состојба „размислување“ и ја суспендира нишката за да симулира поминување на време во мислење.

Други важни методи во оваа класа се: `clear()` методот кој ја враќа состојбата на тековниот `DiningPhilosophersState` објект во првобитната состојба, и `finalize()` методот кој врши проверка за појава на настаните 4. и 3. од горенаведената листа. Нема потреба од посебна проверка за појава на настанот 2. од листата (блокада) бидејќи самата архитектура проверува дали истиот се случил. Поради начинот на забележување на исклучоците во тековната архитектура, при случување на блокада се бележи дека се случило изгладнување иако станува збор за вистинска блокада која всушност е препознаена од самата архитектура. Овој проблем може да се заобиколи доколку се коментира линијата код `throw e;` во `logException()` методот на `AbstractState` класата – во таков случај, се забележува грешка изгладнување и грешка блокада.

Времето на суспендирање на нишките при јадењето и мислењето на филозофот е компаративно мало (од 1 до 10 милисекунди) што значи дека настанот не се симулира во реално време – ова се случува поради тоа што веќе воспоставената архитектура со помош на која се симулира настанот пријавува блокада доколку било која нишка се извршува подолго од 1 секунда (што може да се согледа во `startWithoutDeadlock()` методот на `ProblemExecution` класата).

Дополнителна документација може да се најде во самиот изворен код во вид на коментари.

4. Референци
------------
<sub>1. https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD625.html, Second Solution. As seen on 14.09.2014.</sub><br />
<sub>2. http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD310.html. As seen on 14.09.2014.</sub><br />
<sub>3. Allen B. Downey, The Little Book Of Semaphores v.2.1.5, p. 103, 104</sub>


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

III.
#The Faneuil Hall Problem

Се одржуваат неколку последователни церемониии во салата Фанел, на која присуствуваат три типа на посетители: доселеници, гледачи и судија. Секој од трите типа посетители предизвикува неколку акции и тоа:

Доселениците влегуваат во салата, се пријавуваат, седнуваат на столче, ја кажуваат заклетвата, го земаат сертификатот и ја напуштаат салата. 

*	**enterImmigrant()**
*	**checkIn()**
*	**sitDown()**
*	**swear()**
*	**getCertificate()**
*	**leaveImmigrant()**

Гледачите влегуваат во салата, ја гледаат церемонијата и ја напуштаат салата.

*	**enterSpectator()**
*	**spectate()**
*	**leaveSpectator()**

Судијата влегува во салата, ја потврдува натурализацијата и  ја напушта салата.

*	**enterJudge()**
*	**confirm()**
*	**leaveJudge()**

Но постојат одредени правила на однесување за време на церемонијата.

Доселениците не смеат да влегуваат или да ја напуштаат салата доколку во неа е присутен судија. Не е дозволено повеќе доселеници истовремено да се пријавуваат. Во салата има неограничен број на столови на кои што доселениците можат да седнат и да чекаат судијата да ја потврди натурализацијата за да ја кажат заклетвата (**swear()** не смее да биде повикан од ниту еден доселеник пред да се повика **confirm()** од судијата). Откако судијата ќе ја потврди натурализацијата, доселениците еден по еден ја кажуваат заклетвата и си го земаат сертификатот.

Гледачите не смеат да влезат во салата ако судијата е веќе внатре, но можат да ја напуштат салата во било кое време, ако не сакаат да чекаат да заврши церемонијата.

Истовремено во салата не може да има повеќе судии. Првиот судија може да влезе во било кое време, но останатите мора да чекаат целосно да заврши церемонијата, односно сите доселеници кои биле дел од церемонијата да ја напуштат салата (тоа не значи дека во салата нема други доселеници кои ја чекаат следната церемонија). Присутниот судијата мора да ги почека сите доселеници кои што веќе се внатре во салата да се пријават за да ја потврди натурализацијата (Судијата не може да го повика **confirm()** ако претходно не е повикан **checkIn()** од сите доселеници кои повикале **enterImmigrant()**).


*Сите методи се повикуваат точно во редоследот во кој се напишани во соодветните execute методи на класите Immigrant, Judge и Spectator.*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IV.
Hilzer's Barbershop Problem
===========================
Hilzer’s Barbershop Probleм претставува покомплицирана верзија на класичниот проблем на берберница (Barbershop Problem).

  Во овој проблем берберницата има повеќе столчиња за потстрижување (исто колку и бербери), повеќе бербери (но не повеќе од 15) и просторија за чекање која се состои од една софа на која може да се сместат најмногу 4 клиенти и простор за стоење. Ограничувањата се дека во берберницата не смее во ниеден момент да има повеќе од 20 клиенти (ова ги вклучува столчињата, софата и просторот за стоење). Од ова ограничување произлегува и ограничувањето за берберите и столчињата, бидејќи секој клиент мора прво да чека стоечки, па да чека седечки, па да оди на столчето за потстрижување, па ако ставиме повеќе од 15 бербери ќе нема место за стоење.

  Клиент не смее да влезе во берберницата ако нејзиниот капацитет е исполнет (внатре веќе има 20 клиенти).  
Откако ќе влезе, клиентот стои додека да се ослободи место на софата (да има помалку од 4 клиенти на софата). 
Кога некој бербер е слободен, еден од клиентите (не е важно кој) кои седат на софата се префрлува на неговото столче за потстрижување и му сигнализира на берберот дека тој е спремен за потстрижување.  
Во овој момент ако има клиенти кои стојат, еден од нив (не е важно кој) седнува на софата.  
Кога некој од клиентите е готов со потстрижувањето тој плака кај било кој од берберите (немора кај тој што го потстрижувал).   Повеќе клиенти може да плаќаат во исто време.  
Берберите своето време го делат помегу: потстрижување, наплаќање и чекање да дојде клиент на нивото столче.  

Со други зборови, следниве ограничувања треба да важат при синхронизацијата: 
+ Клиентите ги повикуваат следниве функции и тоа стрикно во овој редослед: **enterShop**,  **sitOnSofa**,  **sitInBarberChair**, **getHairCut**, **pay**, **exitShop**. 
+ Берберите ги повикуваат: **cutHair**, **acceptPayment**.

#### -   enterShop()
+ Секој клиент ја повикува при влез во берберницата.
+ Клиентите не може да ја повикаат enterShop ако капацитетот на берберницата е исполнет. 

---
#### -   sitOnSofa()
+ Секој клиент ја повикува при седнување на софата.
+ Највеќе 4 клиенти можат да седат на софата истовремено.
+ Ако капацитетот на софата е полн, клиент којшто пристигнал не може да ја повика **sitOnSofa** додека еден од клиентите на софата не ја повика **sitInBarberChair**. 

---
#### -   sitInBarberChair()
+ Секој клиент ја повикува при седнување на берберскиот стол.
+ Ако сите бербер(и) се зафатени, клиентот не може да ја повика **sitInBarberChair** додека еден од клиентите кои се потстрижуваат не ја повика **exitShop**. 

---
#### -   getHairCut()
+ Секој клиент ја повикува по седнувањето на берберскиот стол.
+ Мора да биде повикана пред берберот да ја повика **cutHair**.

---
#### -   pay()
+ Секој клиент ја повикува откако ке биде потстрижан.
+ Клиентот мора да ја повика pay пред берберот да  ја повика acceptPayment. 
+ Клиентот не може да ја повика **exitShop** пред да плати.

---
#### -   exitShop()
+ Секој клиент мора да бил потстрижан пред да може да излезе.
+ Берберот мора да ја повика acceptPayment пред клиентот да ја повика exitShop. 

---
---

#### -   cutHair()
+ Секој бербер ја повикува кога ќе има присутен клиент на некој од столовите.
+ Клиентот мора да ја повикал **getHairCut** пред да биде повикана оваа функција.

---
#### -   acceptPayment()
+ Секој бербер ја повикува по потстрижувањето на клиент.
+ Клиентот мора да ја повикал **pay** пред да биде повикана оваа функција.

---

**Ниедна од функциите не смее да се повика повеќе од еднаш и вон дадениот редослед.**  
Се користат семафори и бројачи по желба. Тие треба да се дефинитат на почетокот од класата и треба да се static.  
Се иницијализираат во методот **init()**.  
Треба да се имплементираат методите execute() во секоја од двете класи (Barber и Customer) користејќи ги претходно споменатите методи.  
Не смеат да се користат try-catch блокови во **execute()** методите.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
V.
# River Crossing Problem 

Семинарска работа по предметот Оперативни Системи 2013/2014,<br />
Факултет за Информатички Науки и Компјутерско Инженерство

Семинарската работа е изработена од:<br />
Петре Петров <br />
Ивица Обадиќ

1. Опис на проблемот
--------------------

Некаде близу Редмонд, Вашингтон, има брод кој го користат Linux хакерите (hackers) и вработените во Microsoft (serfs), за премин на реката за да стигнат на работното место. Бродот се дивижи од едната на другата страна на реката ако и само ако на него се качат точно четворица патници.  Поради големото ривалство на вработените од двете компании, не е дозволено на бродот да има еден вработен од едната и тројца вработени од другата компанија. Сите други комбинации се дозволени. Од таа причина, ве изнајмуваат вас да направете софтвер кој ќе го регулира преминот на реката.

Во почетниот код кој е даден, дефинирани се класите Hacker и SerfОд секоја од класите паралелно се активни повеќе инстанци кои на бродот може да се качат само еднаш.

Во имплементацијата мора да ги искористите следните методи од веќе дефинираната променлива state:
	

##  -  	state.board() 
- секој вработен кој се качува на бродот ја повикува оваа функција,
- треба да гарантирате дека секој од четирите патници кои се качуваат на бродот го има повикано овој метод пред да биде повикан методот rowboat().
	

##  -   state.rowBoat()   
- методот треба да биде повикан откако претходно сите четири патници го повикале методот board()
- треба да гарантирате дека методот ќе биде повикан само од еден од четворицата патници, независно од кој.

Вашата задача е да ги имплементирате методите 

	Hacker.cross()
	Serf.cross() 
	init().
 При имплементацијата не смеете да користите try-catch блокови во нив. Потребните семафори и глобални променливи треба да ги дефинирате самите.

Доколку имате грешка, ќе ја добиете пораката:

	Procesot ne e sinhroniziran spored uslovite na zadacata.

После пораката ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена:
 Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
VI.
Roller coaster problem

Да претпоставиме дека имаме n нишки на патници и една нишка на кола.
После секое возење патниците повторно чекаат ред за да се возат со колата, која може да 
вози само со точно 10 патници, каде 10 < n.

- Патниците треба да повикаат board() и unboard()
- Колата треба да повика load(), run() и unload()
- Патниците неможе да се качуваат пред колата да повика load()
- Колата неможе да го започне возењето ( run() ) се додека 10 патници не повикаат board()
- Патниците неможе да повикаат unboard() пред колата да повика unload()
- На крај од секое возење треба да се повика методот validate() само еднаш со цел да се провери дали колата е целосно празна и завршила со возење

Колата ги повикува методите:
- load() - метода со која се обезбедува една кола потребна за возење, патниците неможат да се качуваат во колата ( board() ) пред да се повика овој метод.

- run() - метода која се повикува откако ќе има точно 10 патници во колата.

- unload() -  метода со која се ослободува колата за следно возење, патниците неможат да излегуваат од колата ( unboard() ) доколку пред тоа не е повикан овој метод.

Патникот ги повикува методите:
- board() - метода со која патниците влегуваат во колата, која неможе да се повика доколку предходно не е повикано load().

- unboard() - метода со која патниците излегуваат од колата, која неможе да се повика доколку предхнодно не е повикано unload().
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
VII.
<html>
<head>
<meta charset="UTF-8">
</head>

<body>
<p>

<h1><strong>The Party Room Problem</strong></h1>

<pre>
The Party Room Problem започнува од деканот кој има потреба да ја пребара собата на студентите. Има неколку главни
ограничувања на кои мора да се задржиме :

<ol>
 <li>Бројот на студенти во собата не е ограничен</li>
 <li>Деканот може да влезе во собата ако бројот на студенти во неа е 0 (празна) или ако има повќе од 50 студенти(ја растура нивната забава)</li>
 <li>Кога деканот е во собата студентите може само да излегуваат но не и да влегуваат</li>
 <li>Деканот не смее да ја напушти собата додека сите студенти не ја напуштат</li>
 <li>Има само еден декан (не мора да се синхронизира слочајот за влез на повеќе декани)</li>
</ol>  




<h2>Основни методи кои мора да ги имплементирате</h2>

Променливата state содржи повеќе функции и тоа се : 


 - void studentEnter()
	
	Сигнализира влез на еден студент. Ако студентот проба да влезе додека 
	деканот се наоѓа во собата исфрла грешка
	
	
 - void dance()
 
	Сигнализира почеток на забавата

 - void deanEnter()
 
	Сигнализира влез на деканот. Тоа е возможно во два случаеви и тоа да нема 
	студенти во собата или да има повеќе од 50 студенти во собата(има забава)

	
 - void studentLeave()
 
	Сигнализира заминување на студент од собата

 - void deanLeave()
 
	Сигнализира заминување на деканот. Кој не смее да ја напушти собата додека сите студенти не излезат
	

 - void breakUpParty()

	Деканот ја прекинува забавата. Може да ја расипе забавата ако има повеќе од 50 студенти.
	
 - void conductSearch()
 
	Деканот извршува пребарување на собата. Тоа е возможно ако нема присутни студенти.

<h2>Откривање на грешки</h2>


Доколку имате грешка, ќе ја добиете пораката:

	Procesot ne e sinhroniziran spored uslovite na zadacata.

После пораката ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена:
 Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.


</pre>
<p>

</body>
</html>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	VIII.
# THE SANTA CLAUS PROBLEM

Дедо Мраз одмара во својата фабрика на Северниот Пол. Него може да го повикаат ирвасите кога ќе се вратат од Јужниот Пацифик за да им ја припреми санката, или елфовите кои имаат потешкотии при правењето на играчки (им недостигаат алатки за работа). За ирвасите да го повикаат Дедо Мраз мора сите 9 да се вратени од нивниот одмор во тропските предели. За елфовите да го повикаат да им донесе алатки мора 3 од нив да се присутни во работилницата (за да не мора постојано секој елф да го малтретира :-D ). 9 - тиот ирвас и 3 - тиот елф го повикуваат Дедо Мраз за да им пружи помош. Ако истовремено се присутни 3 елфови и 9 - те ирваси, тогаш Дедо Мраз ќе им даде приоритет на ирвасите. Кога 3 елфови се наоѓаат во работилницата, секој нареден што ќе дојде мора да чека претходните 3 да завршат.

Има една инстанца од нишката Дедо Мраз (Santa), поголем број на инстанци од нишката Елф (Elf) и точно девет инстанци од нишката Ирвас (Reindeer). Santa ќе се изврши онолку пати колку што е потребно за да ги задоволи и елфовите и ирвасите. Сите инстанци од Elf ќе се извршат по еднаш и 9 - те инстанци од Reindeer ќе се извршат по еднаш.

Треба да се повикаат методите во секоја од класите како што е наведено:

•	state.reindeerArrived() - го повикува секој од ирвасите кога ќе пристигне на Северниот Пол. Го симболизира враќањето на ирвасот од одмор.

•	state.getHitched() - го повикува секој од ирвасите откако Дедо Мраз ќе ја припреми санката. Го симболизира поставувањето на ирвасот на своето место за да може да ја влече санката. Ако претходно не се сите ирваси пристигнати, овој метод ќе фрли исклучок. Ако Дедо Мраз не ја припремил претходно санката, овој метод ќе фрли исклучок.

•	state.prepSleigh() - го повикува Дедо Мраз. Го симболизира подготвувањето на санката. Ако Дедо Мраз бил повикан да ја припреми санката пред да пристигнат сите 9 ирваси, овој метод ќе фрли исклучок. Откако ќе ја припреми санката Дедо Мраз ги остава ирвасите да се сместат.

•	state.elfEntered() - го повикува секој од елфовите. Го симболизира влегувањето на елфот во работилницата. Ако некој елф влезе додека во работилницата има уште елфови кои работат или чекаат Дедо Мраз да им ги донесе алатките, овој метод ќе фрли исклучок.

•	state.getHelp() - го повикува секој од елфовите. Го симболизира земањето на алатките од Дедо Мраз и завршувањето со својата работа на правење играчки. Ако при првиот повик на овој метод немало 3 елфови кои чекаат помош, овој метод ќе фрли исклучок. Ако Дедо Мраз не ги има донесено алатките, овој метод ќе фрли исклучок.

•	state.helpElves() - го повикува Дедо Мраз. Го симболизира носењето на алатки на елфовите. Ако 9 - те ирваси чекаат кога овој метод ќе биде повикан, се фрла исклучок поради повисокиот приоритет на ирвасите. Ако не се присутни 3 елфови во работилницата (ако Дедо Мраз бил повикан да ги донесе алатките пред време), овој метод ќе фрли исклучок.

Се користат семафори и бројачи по желба. Тие треба да се иницијализираат во методот init(). Треба да се имплементираат методите execute() во секоја од трите класи користејќи ги претходно споменатите методи.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	IX.
The Senate Bus Problem
=============

<h3>Опис на проблемот</h3>
<p align="justify">
Овој проблем е оригинално базиран на проблемот со автобусите на колеџот Wellesley.
Патниците пристигнуваат на автобуска станица и чекаат автобус. Кога даден автобус ќе пристигне на автобуската станица сите патници кои моментално чекаат на станицата пробуваат да се качат во автобусот, но секој патник кој ќе пристигне по пристигнувањето на автобусот ќе мора да го чека следниот автобус.
Капацитетот на секој од автобусите е 50 лица. Ако на автобуската станица чекаат повеќе од 50 патници, некои од нив ќе мора да го чекаат наредниот автобус за да се качат. Кога сите предвидени патници за тековниот автобус ќе се качат во истиот, тој си заминува од автобуската станица. Ако даден автобус пристигне во момент кога на автобуската станица не чека ниту еден патник, во тој случај автобусот треба веднаш да си замине.
</p>

<h3>Ограничувањa</h3>
- Не е дозволено повеќе од 50 патници да се качат во еден автобус.<br/>
- Не е дозволено повеќе од еден автобус да стои на автобуската станица во даден момент.<br/>
- Даден автобус не смее да ја напушти автобуската станица доколку во него не се качени сите патници(не повеќе од 50) кои првично биле на станицата кога тој пристигнал.<br/>
- Во даден автобус не е дозволено да влегуваат патници кои пристигнале на автобуската станица во момент кога тој веќе бил пристигнат на неа.<br/>
- Даден автобус не смее да стои на автобуската станица доколку при неготово пристигнување на неа немало ниту еден патник. Во ваквиот случај автобусот треба веднаш да си замине.<br/>
- Автобусот треба да ги повукува методите busArrives() и busDeparts().<br/>
- Патниците е потребно да ги повикуваат методите riderArrives() и riderBoardsBus().<br/>

<h3>Методи</h3>
Автобусот ги повикува методите:<br/>
- <strong>state.busArrives()</strong>
  - метода со која даден автобус пристигнува на автобуската станица<br/>
- <strong>state.busDeparts()</strong>
  - метода со која даден автобус си заминува од автобуската станица
  - оваа метода не може да биде повикана доколку претходно не е повикана методата <code>state.busArrives()</code><br/>

Патникот ги повикува методите:<br/>
- <strong>state.riderArrives()</strong>
  - метода со која еден патник пристигнува на автобуската станица<br/>
- <strong>state.riderBoardsBus()</strong>
  - метода со која даден патник, кој тековно чека на автобуската станица, се качува во автобусот кој се наоѓа на истата 
  - оваа метода не може да биде повикана доколку претходно не е повикана методата <code>state.riderArrives()</code> за дадениот патник и <code>state.busArrives()</code> за соодветниот автобус<br/>

<h3>Задача</h3>
<p align="justify">
Протребно е да се напише програмски код за синхронизација на горенаведените настани притоа обрнувајќи внимание на зададените ограничувања и користејќи ги понудените методи.
</p>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X.
Sushi Bar Problem
===========================
Еден суши бар има место за 5 посетители. Доколку некој поестител дојде во барот кога има слободно место,
тој може веднаш да седне, но доколку дојде во момент кога сите 5 места се зафатени, тоа значи дека групата
e заедно дојдена и ќе мора да почека сите да станат за да може да седне (Внимание: Доколку еден посетител ја напушти групата не значи дека групата е готова
т.е. доколку има посетители кои чекаат ќе мора да почекаат и другите членови да ја напуптат групата). 

			Вашата задача е да го синхронизирате претходното сценарио.

Во почетниот код кој е даден, дефинирана е класата Customer, која го симболизира однесувањето на посетителите на суши барот.
Има повеќе инстанци од класата Customer кај кои методот execute() се повикува повеќе пати.

Во имплементацијата, можете да ги користите следните методи од веќе дефинираната променлива state:

---
#### -   state.seat()

•Служи за проверка дали има место во барот и доколку има место седнува на масата. Доколку се повика додека барот е полн или пак додека групата сеуште е присутна ќе фрли исклучок.

---
#### -   state.groupGathered()

•Го симболизира собирањето на групата. Се повикува од 5тиот член кога ќе седне на масата. Доколку се повика кога на масата нема 5 посетители ќе фрли исклучок.

---
#### -   state.eat()

•Го симболизира времето додека посетителот седи во барот.

---

#### -   state.groupDone()

•Го симболизира излагањето на групата од барот. Се повикува од последниот член на групата кога го напушта барот. Доколку се повика кога на масата сеуште има посетители ќе фрли исклучок.

---
#### -   state.done()

•Го симболизира напуштањето на посетител од барот. Се повикува од секој посетител кој го напушта барот освен од последниот член на групата кој оваа функција ја извршува
со методот **state.groupDone()**. Доколку се повика додека нема никој присутен во барот ќе фрли исклучок.

---

Претходно назначените методи служат за проверка на точноста на сценариото и не смеат да бидат променети и мораат да бидат повикани.

Вашата задача е да ги имплементирате методите Customer.execute() и init(). При имплементацијата, не смеете да додадете try-catch блок во нив. 
Потребните семафори, глобални променливи и променливи за состојбите нa посетителите треба да ги дефинирате самите.

Доколку имате грешка, ќе ја добиете пораката:

Procesot ne e sinhroniziran spored uslovite na zadacata
По што ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена: Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. 
Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.
