1.
Задача1: Producer - Controller
 ● Проблем: Producer–Controller, со ограничен број 
проверки.​
 ● Потребно е да направите оптимизација на додавањата и 
проверките на податоците од одреден бафер според 
следните услови:​
 ● Кога се додава податок во баферот, во истиот момент:​
 ○ Не може да има додавање на други податоци​
 ○ Не може да се прави проверка на податоци​
 ● Кога се прави проверка на податоци, во истиот момент:​
 ○ Може да има максимум 10 активни проверки​
 ○ Не може да има додавање пред да завршат сите 
започнати проверки​
 ● Иницијално во баферот има податоци.​
Задача1: Producer - Controller
 ● Баферот е претставен со инстанцата buffer од класата 
Buffer. Притоа може да ги користите следните методи:​
 ○ state.produce()
 ■ Додава елемент во баферот.​
 ■ Фрла RuntimeException со соодветна порака 
доколку во истиот момент се врши додавање или 
проверка на друг податок.
 ○ state.check()
 ■ Врши проверка на податок од баферот.​
 ■ Проверува дали во истиот момент се врши 
додавање или паралелна проверка на повеќе од 
10 податоци.​
Задача1: Producer - Controller
 ● Имплементирајте ги методите execute() од класата Producer и Controller, 
кои ќе функционираат според претходните правила. ​
 ● Тие треба да ги користат методите state.produce() и  state.check() за 
додавање и проверка на податоци од баферот, соодветно. ​
 ● Сите семафори и глобални променливи треба да ги дефинирате самите, 
а нивната иницијализација да ја направите во методот init(). ​
 ● При имплементацијата на методите, не смеете да додадете try-catch 
блокови во методите. (Важно при тестирањето)​
 ● При извршувањето има повеќе инстанци од класите Producer и 
Controller, кои вршат повеќе од едно додавање и проверка, соодветно. ​
 ● Додавањата и проверките се стартуваат (скоро) истовремено и 
паралелно се извршуваат.

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerController {
    static int MAX_PRODUCTION=50;
static Semaphore addingInBuffer;
static Semaphore checkingData;
static Lock lock;
    static int numControllers = 0;
public static void init(){
    addingInBuffer=new Semaphore(1);
    lock=new ReentrantLock();
    checkingData=new Semaphore(10);
}
public static class Buffer{
private boolean producing=false;
private int checking=0;
    public  void produce(){
producing=true;
if (checking>0){
   throw new RuntimeException("Can't produce if someone is checking... ");

}
        System.out.println("Producing...");
producing=false;
    }
    public  void check(){
checking++;
if (producing){
    throw  new RuntimeException("Can't check if there is producing...");
}
        if (checking>10){
            throw  new RuntimeException("Can't check more than 10 processes...");
        }

        System.out.println("Controler is checking...");
    checking--;
    }

}

    public static class Producer extends Thread{
private final Buffer buffer;
public Producer(Buffer b){
    buffer=b;
}
public void execute() throws InterruptedException{
    addingInBuffer.acquire();
    buffer.produce();
    addingInBuffer.release();
}

@Override
        public void run(){
    for (int i = 0; i <MAX_PRODUCTION ; i++) {
        try {
            execute();
        } catch (InterruptedException io) {
            io.printStackTrace();
        }
    }
}
    }
    public static class Controller extends Thread{
private final Buffer buffer;
public Controller(Buffer b){
    buffer=b;
}

public void execute() throws InterruptedException{
    lock.lock();
    if (numControllers==0){
        addingInBuffer.acquire();
    }
numControllers++;
    lock.unlock();

    checkingData.acquire();
    buffer.check();

    lock.lock();
    numControllers--;
checkingData.release();
if (numControllers==0){
    addingInBuffer.release();
}
lock.unlock();
}
public void run(){
    for (int i = 0; i <MAX_PRODUCTION ; i++) {
        try {
            execute();
        } catch (InterruptedException io) {
            io.printStackTrace();
        }
    }
}
    }
    public void main(String[] args){
Buffer buffer=new Buffer();
Producer p=new Producer(buffer);
        List<Controller>controllers=new ArrayList<>();
        for (int i = 0; i <100 ; i++) {
            controllers.add(new Controller(buffer));
        }
p.start();
        for (int i = 0; i <100 ; i++) {
            controllers.get(i).start();
        }
    }
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.
● Да се имплементира синхронизација на проблемот со 
произведувач и потрошувач. Притоа, имаме еден 
произведувач кој поставува ставки во бафер и 
произволен број на потрошувачи кои паралелно ги 
земаат поставените ставки.​
 ● Иницијално баферот е празен.​
Задача 2: Произведувач- Потрошувач
 ● Произведувачот врши полнење на баферот со користење на 
функцијата state.fillBuffer();
 ● Потрошувачот ја зема ставката наменета за него со методот 
state.getItem(int id);
 ● Потрошувачот ја зема само ставката наменета за него, по 
што чека ново полнење на баферот.
 ● По земањето на ставката од баферот, потрошувачот треба 
повика state.decrementNumberOfItemsLeft() за да каже дека ја 
земал ставката.​
 ● Потрошувачот кој ќе ја земе последната ставка (го оставил 
баферот празен) му сигнализира на произведувачот за да го 
наполни баферот.​
 ● За проверка дали баферот е празен да се користи 
state.isBufferEmpty();
Задача 2: Произведувач- Потрошувач(Ограничувања)
 ● Треба да се овозможи повеќе потрошувачи паралелно 
да може да си ја земат својата ставка од баферот.​
 ● Паралелно повикување на state.getItem(int id);
 ● Не смее да се повика state.getItem(int id) доколку 
соодветната ставка претходно е земена и не е 
поставена.​
 ● Не смее да се повика state.fillBuffer()доколку има ставки 
во баферот.​
 ● Повиците state.isBufferEmpty()и 
state.decrementNumberOfItemsLeft()го модифицираат 
тековниот број на ставки во баферот.​
Задача 2: Произведувач- Потрошувач
 ● Да се имплементираат методите init(), Producer.execute() и 
Consumer.execute(), при што ќе се изведе синхронизација за да се 
извршуваат според дефинираните услови.​
 ● При извршувањето има една инстанца од Producer и повеќе инстанци од 
Consumer класата кои се извршуваат паралелно. ​
 ● Претпоставете дека методот execute() и кај двете класи се повикува во 
бесконечна while јамка. ​
 ● Решение:​
 ● Кодот е поставен на курсот

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProizveduvacPotrosuvac {
    static final int NUM_RUNS=100;
    static final int NUM_CONSUMERS=50;
    static Lock lock;
static Semaphore isBufferEmpty;
static Semaphore[] item;
public static void init(){
    lock=new ReentrantLock();
    isBufferEmpty=new Semaphore(1);
    item=new Semaphore[NUM_CONSUMERS];
    for (int i = 0; i <NUM_CONSUMERS ; i++) {
        item[i]=new Semaphore(0);
    }
}
static class Buffer{
private final int numConsumers;
public Buffer(int numConsumers){
    this.numConsumers=numConsumers;
}
private int numItems=0;
public int getBufferCapacity(){
    return numConsumers;
}
public void fillBuffer(){
if (numItems!=0){
    throw new RuntimeException("The buffer is not empty...");
}
numItems=numConsumers;
    System.out.println("The buffer is full...");
}
public void decrementNumberOfItemsLeft(){
if (numItems<=0){
    throw new RuntimeException("Can't decrement, there is no items...");
}
numItems--;
}
public boolean isBufferEmpty(){
   return numItems==0;
}
    public void getItem(int consumerID){
        System.out.println(String.format("Get item for consumer with id: %d",consumerID));
    }
}
public static class Producer extends Thread{
private Buffer buffer;
public Producer (Buffer b){
    buffer=b;
}
    public void execute()throws InterruptedException{
isBufferEmpty.acquire();
lock.lock();
buffer.fillBuffer();
lock.unlock();

        for (int i = 0; i <NUM_CONSUMERS ; i++) {
            item[i].release();
        }
    }
@Override
    public void run(){
    for (int i = 0; i <NUM_CONSUMERS ; i++) {
        try {
            execute();
        }catch (InterruptedException io){
            io.printStackTrace();
        }
    }
}

}

public static class Consumer extends Thread{
private Buffer buffer;
private int consumerID;
    public Consumer(int consumerId, Buffer buffer) {
        this.buffer = buffer;
        this.consumerID = consumerId;
    }

public void execute()throws InterruptedException{
        
item[consumerID].acquire();
buffer.getItem(consumerID);
lock.lock();
buffer.decrementNumberOfItemsLeft();
if (buffer.isBufferEmpty()){
    isBufferEmpty.release();
}
lock.unlock();
}
@Override
    public void run(){
    for (int i = 0; i <NUM_RUNS ; i++) {
        try{
            execute();
        }catch (InterruptedException io){
            io.printStackTrace();
        }
    }
}
}
public static void main(String[] args){
    init();
    Buffer buffer=new Buffer(NUM_CONSUMERS);
    Producer p=new Producer(buffer);
    List<Consumer>consumers=new ArrayList<>();
    for (int i = 0; i <NUM_CONSUMERS ; i++) {
consumers.add(new Consumer(i,buffer));
    }

    for (int i = 0; i < NUM_CONSUMERS; i++) {
        consumers.get(i).start();
    }
}

}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3.
Паралелнопребарувањеи броење
 Да се имплементирапаралелнопребарувањена броеви низголема
 низа. Се бара колкупатисе појавува даденбројs воцелатаниза. Со цел
 побрзо пребарување, низата се делина t број еднакви делови, кадеt е 
бројот на стартувани нитки.
 Откакосите ниткиќезавршат со броење, главната ниткапечети колкупати
 е најден бараниот број вонизата. На крајниткатакоја ги нашла најголемиот
 број на појавувањаво својот дел го печатитоа на излез.
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Lock;

public class ElementCount {

    static long count = 0;
    static long max = 0;
    static Lock lock = new ReentrantLock();
    static Semaphore done = new Semaphore(0);
    static Semaphore canCheckMax = new Semaphore(0);

    static final BoundedRandomGenerator random = new BoundedRandomGenerator();
    private static final int ARRAY_LENGTH = 10000;
    private static final int NUM_THREADS = 10;

    private static final int SEARCH_TARGET = 5;  // This is the target element we are looking for

    // TODO: Define sychronization elements and initialize

    // DO NOT CHANGE
    public static int[] getSubArray(int[] array, int start, int end) {
        return Arrays.copyOfRange(array, start, end);
    }

    public static void main(String[] args) throws InterruptedException {

        int[] arr = ArrayGenerator.generate(ARRAY_LENGTH, SEARCH_TARGET);

        // TODO: Make the SearchThread class a thread and start 10 instances
        // Each instance should take a subarray from the original array with equal length

        List<CountThread> countThreads = new ArrayList<>();
        int elementsPerThread = arr.length / NUM_THREADS;

        for (int i = 0; i < NUM_THREADS; i++) {
            int[] subarray = getSubArray(arr, i * elementsPerThread, (i+1) * elementsPerThread);
            countThreads.add(new CountThread(subarray, SEARCH_TARGET));
        }

        for (CountThread countThread : countThreads) {
            countThread.start();
        }

        // all threads done
        done.acquire(NUM_THREADS);
        canCheckMax.release(NUM_THREADS);

        // check max count
        // TODO: Start the 10 threads


        // DO NOT CHANGE

        System.out.println("The number of total counted elements is: " + count);
        System.out.println("The generated number of elements is: " + ArrayGenerator.elementCount);

        // TODO: The max thread should print the number of occurences

    }

// TO DO: Make the SearchThread class a thread
// You can add methods or attributes if necessary
    static class CountThread extends Thread {

        private int[] arr;
        private int target;


        public CountThread(int[] arr, int target) {
            this.arr = arr;
            this.target = target;
        }

        public void countElements() {
            for (int num: this.arr) {
                if (num == target) {
                    count++;
                }
            }
        }

        public void countElementsParallel() throws InterruptedException {
            // TO DO: Implement and run the parallel counting method from the thread
            int localCount = 0;
            for (int num: this.arr) {
                if (num == target) {
                    localCount++;
                }
            }

            lock.lock();
            count+=localCount;
            if (localCount > max) {
                max = localCount;
            }
            lock.unlock();

            // i'm done
            done.release();
            // request to check count
            canCheckMax.acquire();
            if (localCount == max) {
                System.out.printf("Thread with id %d counted max %d\n", threadId(), localCount);
            }

        }

        public void run() {
            try {
                countElementsParallel();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    //************ DO NOT CHANGE ************//
    static class BoundedRandomGenerator {
        static final Random random = new Random();
        static final int RANDOM_BOUND = 100;

        public int nextInt() {
            return random.nextInt(RANDOM_BOUND);
        }

    }

    static class ArrayGenerator {

        static int elementCount;

        static int[] generate(int length, int target) {
            int[] array = new int[length];

            for (int i = 0; i < length; i++) {
                int element = ElementCount.random.nextInt();

                if (element == target) {
                    elementCount++;
                }

                array[i] = element;
            }

            return array;
        }
    }


}

