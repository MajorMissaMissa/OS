1.
Задача1: Producer - Controller
 ● Проблем: Producer–Controller, со ограничен број 
проверки.​
 ● Потребно е да направите оптимизација на додавањата и 
проверките на податоците од одреден бафер според 
следните услови:​
 ● Кога се додава податок во баферот, во истиот момент:​
 ○ Не може да има додавање на други податоци​
 ○ Не може да се прави проверка на податоци​
 ● Кога се прави проверка на податоци, во истиот момент:​
 ○ Може да има максимум 10 активни проверки​
 ○ Не може да има додавање пред да завршат сите 
започнати проверки​
 ● Иницијално во баферот има податоци.​
Задача1: Producer - Controller
 ● Баферот е претставен со инстанцата buffer од класата 
Buffer. Притоа може да ги користите следните методи:​
 ○ state.produce()
 ■ Додава елемент во баферот.​
 ■ Фрла RuntimeException со соодветна порака 
доколку во истиот момент се врши додавање или 
проверка на друг податок.
 ○ state.check()
 ■ Врши проверка на податок од баферот.​
 ■ Проверува дали во истиот момент се врши 
додавање или паралелна проверка на повеќе од 
10 податоци.​
Задача1: Producer - Controller
 ● Имплементирајте ги методите execute() од класата Producer и Controller, 
кои ќе функционираат според претходните правила. ​
 ● Тие треба да ги користат методите state.produce() и  state.check() за 
додавање и проверка на податоци од баферот, соодветно. ​
 ● Сите семафори и глобални променливи треба да ги дефинирате самите, 
а нивната иницијализација да ја направите во методот init(). ​
 ● При имплементацијата на методите, не смеете да додадете try-catch 
блокови во методите. (Важно при тестирањето)​
 ● При извршувањето има повеќе инстанци од класите Producer и 
Controller, кои вршат повеќе од едно додавање и проверка, соодветно. ​
 ● Додавањата и проверките се стартуваат (скоро) истовремено и 
паралелно се извршуваат.

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerController {
    static int MAX_PRODUCTION=50;
static Semaphore addingInBuffer;
static Semaphore checkingData;
static Lock lock;
    static int numControllers = 0;
public static void init(){
    addingInBuffer=new Semaphore(1);
    lock=new ReentrantLock();
    checkingData=new Semaphore(10);
}
public static class Buffer{
private boolean producing=false;
private int checking=0;
    public  void produce(){
producing=true;
if (checking>0){
   throw new RuntimeException("Can't produce if someone is checking... ");

}
        System.out.println("Producing...");
producing=false;
    }
    public  void check(){
checking++;
if (producing){
    throw  new RuntimeException("Can't check if there is producing...");
}
        if (checking>10){
            throw  new RuntimeException("Can't check more than 10 processes...");
        }

        System.out.println("Controler is checking...");
    checking--;
    }

}

    public static class Producer extends Thread{
private final Buffer buffer;
public Producer(Buffer b){
    buffer=b;
}
public void execute() throws InterruptedException{
    addingInBuffer.acquire();
    buffer.produce();
    addingInBuffer.release();
}

@Override
        public void run(){
    for (int i = 0; i <MAX_PRODUCTION ; i++) {
        try {
            execute();
        } catch (InterruptedException io) {
            io.printStackTrace();
        }
    }
}
    }
    public static class Controller extends Thread{
private final Buffer buffer;
public Controller(Buffer b){
    buffer=b;
}

public void execute() throws InterruptedException{
    lock.lock();
    if (numControllers==0){
        addingInBuffer.acquire();
    }
numControllers++;
    lock.unlock();

    checkingData.acquire();
    buffer.check();

    lock.lock();
    numControllers--;
checkingData.release();
if (numControllers==0){
    addingInBuffer.release();
}
lock.unlock();
}
public void run(){
    for (int i = 0; i <MAX_PRODUCTION ; i++) {
        try {
            execute();
        } catch (InterruptedException io) {
            io.printStackTrace();
        }
    }
}
    }
    public void main(String[] args){
Buffer buffer=new Buffer();
Producer p=new Producer(buffer);
        List<Controller>controllers=new ArrayList<>();
        for (int i = 0; i <100 ; i++) {
            controllers.add(new Controller(buffer));
        }
p.start();
        for (int i = 0; i <100 ; i++) {
            controllers.get(i).start();
        }
    }
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.
● Да се имплементира синхронизација на проблемот со 
произведувач и потрошувач. Притоа, имаме еден 
произведувач кој поставува ставки во бафер и 
произволен број на потрошувачи кои паралелно ги 
земаат поставените ставки.​
 ● Иницијално баферот е празен.​
Задача 2: Произведувач- Потрошувач
 ● Произведувачот врши полнење на баферот со користење на 
функцијата state.fillBuffer();
 ● Потрошувачот ја зема ставката наменета за него со методот 
state.getItem(int id);
 ● Потрошувачот ја зема само ставката наменета за него, по 
што чека ново полнење на баферот.
 ● По земањето на ставката од баферот, потрошувачот треба 
повика state.decrementNumberOfItemsLeft() за да каже дека ја 
земал ставката.​
 ● Потрошувачот кој ќе ја земе последната ставка (го оставил 
баферот празен) му сигнализира на произведувачот за да го 
наполни баферот.​
 ● За проверка дали баферот е празен да се користи 
state.isBufferEmpty();
Задача 2: Произведувач- Потрошувач(Ограничувања)
 ● Треба да се овозможи повеќе потрошувачи паралелно 
да може да си ја земат својата ставка од баферот.​
 ● Паралелно повикување на state.getItem(int id);
 ● Не смее да се повика state.getItem(int id) доколку 
соодветната ставка претходно е земена и не е 
поставена.​
 ● Не смее да се повика state.fillBuffer()доколку има ставки 
во баферот.​
 ● Повиците state.isBufferEmpty()и 
state.decrementNumberOfItemsLeft()го модифицираат 
тековниот број на ставки во баферот.​
Задача 2: Произведувач- Потрошувач
 ● Да се имплементираат методите init(), Producer.execute() и 
Consumer.execute(), при што ќе се изведе синхронизација за да се 
извршуваат според дефинираните услови.​
 ● При извршувањето има една инстанца од Producer и повеќе инстанци од 
Consumer класата кои се извршуваат паралелно. ​
 ● Претпоставете дека методот execute() и кај двете класи се повикува во 
бесконечна while јамка. ​
 ● Решение:​
 ● Кодот е поставен на курсот
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3.
Паралелнопребарувањеи броење
 Да се имплементирапаралелнопребарувањена броеви низголема
 низа. Се бара колкупатисе појавува даденбројs воцелатаниза. Со цел
 побрзо пребарување, низата се делина t број еднакви делови, кадеt е 
бројот на стартувани нитки.
 Откакосите ниткиќезавршат со броење, главната ниткапечети колкупати
 е најден бараниот број вонизата. На крајниткатакоја ги нашла најголемиот
 број на појавувањаво својот дел го печатитоа на излез.
