=============================================================================================================================================================
1.
Направете скрипта која за секој активен процес прво го печати неговиот ID, па бројот на неговиот татко,
па ве прашува дали да го убие процесот, и во зависност од одговорот изведува соодветна акција.	

ps -l|cat > dat.tmp
m=`cat dat.tmp|wc -l`
m=`expr $m - 1`
`tail -$m dat.tmp > temp.tmp`
`cat temp.tmp > dat.tmp`
awk '{print $2}' dat.tmp > PID
awk '{print $3}' dat.tmp > PPID
echo "Brojot na procesi e:" $m
count1=1
count2=1
for i in `cat PID`
do
   count2=1
   tmpPID=$i
   for j in `cat PPID`
   do
      if [ $count1 -eq $count2 ] 
      then
         tmpPPID=$j
      fi
      count2=`expr $count2 + 1`
   done
   count1=`expr $count1 + 1`
   echo "PROCES PID: " $tmpPID " PPID: " $tmpPPID
   echo "Dali sakate da go izbrisete procesot? (d/n)"
   read odg
   if [ $odg = "d" ]
   then 
      kill -1 $tmpPID
   fi
done

2.
Да се креира скрипта avtomat со следново својство: под претпоставка дека во тековниот директориум постои скриптата skripta,
која се повикува со еден аргумент, скриптата avtomat ќе ја извршува skripta со аргумент кој го задава корисникот за време на 
извршувањето на avtomat.. Извршувањето ќе се повторува се додека корисникот не го внесе зборот kraj. Излезот од секое извршување 
на skripta да се пренасочува во датотеката izlez.txt.
На пример, ако skripta го печати својот аргумент, тогаш ако кoрисникот ги внесува последователно зборовите Denes, Utre,
Zadutre, kraj, во датотеката izlez треба да се наоѓаат зборовите  Denes, Utre, Zadutre, секој во нов ред.


#!/bin/bash

touch izlez.txt
while true; do
echo -n  "Vnesete argumenti za skriptata ( ako sakate da prekinete pisete kraj)"
read input
if [ $input == "kraj" ]; then
break
fi
./script "$input" >> izlez.txt
done

3.
 Да се најдат (временски) најновите 7 датотеки  во тековниот директориум чиешто име започнува со poc.
#!/bin/bash

i=7
s="poc'
echo "Datoteki koi zapocnuvaat so poc"
ls -l $s* |grep ^-.*|sort
echo "ima `ls -l $s*|grep ^-.*|wc -l` takvi datoteki."
echo  "od koi $i najnovi se:"
ls -l $s*|grep ^-.*|sort -k 7 |tail -$i

4.
Да се најде колку меморија зафаќаат датотеките во тековниот директориум кои имаат наставка .dat.

c=0
sum=0
for i in `ls -l *.dat`
do
c=`expr $c+1`
if [ $c -eq 5 ]; then
sum=`expr $sum+$i`
fi
if [ $c -eq 9 ]; then
c=0
fi
done
echo "vkupnata golemina e: $sum"
echo
echo "So gotova funkcija goleminata e: `du -bc *.dat|tail -1|awk '{print $1}'`

5.
Да претпоставиме дека сакате да испратите едно исто писмо на повеќе луѓе со корисничко име на системот на
кој сте најавени, со тоа што при обраќање кон личноста сакате да го користите нејзиното лично име, кое е исто 
како корисничкото. Направете скрипта која ќе користи две датотеки: една iminja во која се наоѓаат имињата на вашите пријатели 
и една pismo во која наместо името стои IME, 
и со едно извршување на скриптата писмото ќе биде испратено до сите, со лично обраќање до секого.  


#!/bin/bash
for i in `cat iminja.txt`
do
touch $i.proba
echo "Zdravo $i">>$i.proba
cat poraka.txt>>$i.proba
mail $i<$i.proba
done

5.
Направете, во вид на скрипта, команда за безбедно бришење. Датотеките дадени како аргументи на скриптата не се 
отстрануваат, туку се преместуваат 
во директориумот ~/gjubre.На крај, скриптата ги отстранува сите датотеки од овој директориум кои се постари од еден ден. 

mesec=`date | awk '{ print $2 }'`
datum=`date | awk '{ print $3 }'`
if [ -d ~/gjubre ]
then
	rm -r ~/gjubre
fi
mkdir ~/gjubre
for i in $*
do
	mv $i ~/gjubre
done
cd ~/gjubre
for j in `ls`
do
	m=`ls -l $j | awk '{ print $6 }'`
	d=`ls -l $j | awk '{ print $7 }'`
	if [ ! $mesec = $m -o ! $datum = $d ]
	then
		echo "Ja brisam $j"
		rm $j
	fi
done

6.
Излистајте ги во посебна датотека сите датотеки во вашиот домашен директориум кои се модифицирани 
во тековниот ден (потешка но незадолжителна варијанта: модифицирани во последните 24 часа. Уште потешка: 
наместо во домашниот директориум, во неговото дрво).


#!/bin/bash
if [ -f modificirani ]; then
rm  modificirani
fi

touch modificirani

mesec=`date|awk '{print $2}'`
datum=`date|awk '{print $3}'`
for i in `ls`
do
if [ -f $i ]; then
m=`ls -l $i|awk '{print $6}'`
d=`ls -l $i|awk '{print $7}'`
if [ $mesec =$m -a $datum =$d ];then
echo $i>>modificirani
fi
fi
done

7.
Направете скрипта која на секои 10 секунди ќе проверувадали корисникот student е најавен на системот, 
се додека тој не се најави(со користење на наредбата sleep n , каде n е бројот на секунди). 

while true; then
if who| grep -q "^$username";then
echo "Studentot e logiran"
break
else
echo "Studentot ne e lofiran"
fi
sleep 10
done

8.  Да се направи скрипта која прво проверува дали во тековниот директориум постои поддиректориум backup и доколку не постои го креира. 
Потоа сите датотеки од тековниот директориум ги копира во директориумот backup при сто им додава наставка .backup.

#!/bin/bash

if [ -d backup ];then
echo "Vekje postoi backup datoteka"
else
echo "Kreirame datoteka backup"
mkdir backup
fi
for i in `ls` ; do
if [ -f $i ];then
cp $i backup/
fi
done
cd backup/
echo " Im dodavame nastavka .backup na datotekite"
for i in `ls`
mv $i "$i.backup"
done

9. Со командата date може да се добие денешниот датум. Да претпоставиме дека во вашиот (тековниот) директориум се наоѓаат 3 датотеки со имиња neparen, 
paren, vikend. Да се направи скрипта која во деновите понеделник, среда и петок ќе ја печати на екран содржината на датотеката neparen, во вторник и 
четврток датотеката paren и во сабота и недела датотеката vikend.

#!/bin/bash
v=`date|awk '{print $1}'`

case $v in
Monday)
cat nepraren;;
Tuesday)
cat paren;;
Wednesday)
cat neparen;;
Thursday)
cat paren;;
Friday)
cat neparen;;;
Saturday)
cat vikend;;
Sunday)
cat vikend;;
esac

10. ИСПИТ Септември ( не беше дадено што се бара, туку само решението. Текстот е од ChatGPT )
Опис на решението:
Оваа скрипта го користи логот на најава (last) за да провери дали одреден корисник се најавил на одреден датум во даден временски интервал. Скриптата ги
добива информациите како параметри при извршување.
Функционалност:
Проверка на бројот на аргументи:

Скриптата очекува точно 4 аргументи:
корисничко_име, датум, почетно_време, крајно_време.
Ако аргументите не се доволни, прикажува упатство за употреба и излегува.
Парсирање на датумот:

data може да содржи две вредности (ден и месец), па се поделува на две променливи: prvDel и vtorDel.
Пребарување во логот на најава:

Командата last се користи за да ги пронајде записите за најава на зададениот корисник.
Се филтрираат резултатите со grep за име и датум, а awk ги проверува временските интервали (time1 и time2).
Анализа на резултатите:

Ако постојат записи за најави во зададениот временски интервал:
Се пресметува бројот на најави.
Се извлекуваат IP адресите од записите.
Се креира текстуална датотека (adresi.txt) со уникатни IP адреси.
Се печатат IP адресите на екран.
Ако нема записи, се прикажува порака дека корисникот не се најавил.

nano check_login.sh

#!/bin/bash
//osiguruvanje deka se vneseni cetri argumenti
if [ $# != "4" ];then
echo "USAGE $0 username date time1 time2"
exit 0
fi

ime=$1
data=$2
od=$3
do=$4

b=1
prvDel=  
vtorDel=
for i in $data; do
if [ $b -eq "1" ]; then
prvDel=$i
b=$(($b+1))
else
vtorDel=$i
fi
done
l=`last| grep "$ime"| grep "$prvDel *$vtorDel"|awk '($7>= "$od") && ($7<= "$do") {print;}'`
if [ -n "$l" ]; then
broj= ` echo "$l"|wc -l`
echo "Korisnikot $ime se najavil $broj"
adresi=`echo "$l"|awk '{print $3}'
echo "$adresi"> adresi.txt
uniq adresi.txt > tmp.txt
rm adresi.txt
cat tmp.txt > adresi.txt
rm tmp.txt
echo "Od IP adresite"
cat adresi.txt
else
echo "Korisnikot ne se najavil."
fi

chmod +x check_login.sh

11. ИСПИТ Септември ( не беше дадено што се бара, туку само решението. Текстот е од ChatGPT )
Опис на решението:
Оваа скрипта пресметува како даден износ (suma) може да се претстави со најмал можен број на парички или банкноти со вредности: 50, 10, 5, 2, и 1.
Функционалност:
Влезен параметар:

Скриптата прима еден аргумент: suma, што претставува цел износ кој треба да се подели.
Иницијализација на броевите:

Поставува променливи (brojac50, brojac10, brojac5, brojac2, brojac1) за броење колку парички или банкноти од секоја вредност ќе се користат.
Главна логика (while петла):

Петлата продолжува додека износот (suma) не стане 0.
Во секој чекор, износот се дели со највисоката достапна вредност (50, 10, 5, 2, 1) за да се пресмета колку парички/банкноти ќе се искористат.
Остатокот (suma) се намалува со вкупната вредност на искористените парички/банкноти.
Условна проверка за секоја вредност:

Прво се проверува дали износот е делив со 50. Ако да, се пресметува бројот на банкноти од 50 и се намалува износот.
Истата проверка се прави за 10, 5, 2, и 1.
Параметарот rez го чува бројот на парички/банкноти за дадена вредност, а tmp го чува нивниот вкупен износ.
Резултати:

По завршување на петлата, скриптата го печати оригиналниот износ (s) и бројот на парички/банкноти од секоја вредност што се искористени.

#!/bin/bash
suma=$1
s=$suma
brojac50=0
brojac10=0
brojac5=0
brojac2=0
brojac1=0

while [ $suma -gt 0 ]
do
if [ $(( $suma % 50 )) -eq 0 ]
then
rez=$(( $suma / 50 ))
tmp=$(( $rez * 50 ))
suma=$(( $suma - tmp ))
brojac50=$(( $brojac50 + rez ))
fi

if [ $(( $suma % 10 )) -ge 0 ]
then
rez=$(( $suma / 10 ))
tmp=$(( $rez * 10 ))
suma=$(( $suma - tmp ))
brojac10=$(( $brojac10 + rez ))
fi

if [ $(( $suma % 5 )) -ge 0 ]
then
rez=$(( $suma / 5 ))
tmp=$(( $rez * 5 ))
suma=$(( $suma - tmp ))
brojac5=$(( $brojac5 + rez ))
fi

if [ $(( $suma % 2 )) -ge 0 ]
then
rez=$(( $suma / 2 ))
tmp=$(( $rez * 2 ))
suma=$(( $suma - tmp ))
brojac2=$(( $brojac2 + rez ))
fi


if [ $(( $suma % 1)) -ge 0 ]
then
rez=$(( $suma / 1 ))
tmp=$(( $rez * 1 ))
suma=$(( $suma - tmp ))
brojac1=$(( $brojac1 + rez ))
fi

done
echo "$s : "
echo " $brojac50 * 50 "
echo " $brojac10 * 10 "
echo " $brojac5 * 5 "
echo " $brojac2 * 2 "
echo " $brojac1 * 1"

12. ИСПИТ Јуни ( не беше дадено што се бара, туку само решението. Текстот е од ChatGPT )
Оваа скрипта ги проверува две датотеки (file1 и file2) дали се идентични и ако се, ја брише втората датотека (file2). 
Ако датотеките не се идентични, скриптата ќе ги прикаже разликите.

Функционалност:

Проверка на бројот на аргументи:

Скриптата очекува два аргументи: file1 и file2. Ако не се дадени два аргументи, се печати упатство за користење и скриптата излегува.
Проверка дали датотеките постојат:

Прво се проверува дали file1 и file2 постојат. Ако некоја од нив не постои, се печати порака и се зголемува променливата 
proverka. Ако било која датотека не постои, скриптата излегува.
Читање на содржините на датотеките:

Ако двете датотеки постојат, содржината на file1 и file2 се читаат и се чуваат во променливите dat1 и dat2 со помош на командата cat.
Проверка за идентичност на датотеките:

Скриптата ја проверува дали содржините на двете датотеки се идентични. Ако се, се поставува променливата flag на 1.
Бришење на file2:

Ако датотеките се идентични, скриптата ја брише file2 со помош на командата rm. Потоа проверува дали бришењето е успешно (проверка на вредноста на $?, 
која ја враќа последната извршена команда). Ако бришењето е успешно, се печати порака "Бришењето е успешно". Ако не, се печати порака "Бришењето не е успешно".
Печатење на порака ако датотеките не се идентични:

Ако датотеките не се идентични, се печати порака "Не се исти".


if [ $# != "2"];then
echo "USAGE:$0 file1 file2"
exit 1
fi

proverka=0

//so ovoj del se spravuvame vo slucai koga eden od failovite fali
if [ !-f $1 ];then
echo "file1 ne postoi"
proverka=$(($proverka+1))
fi
if  [ !-f $2 ];then
echo "file2 ne postoi!"
proverka=$(($proverka+1))
fi

if [ $proverka != "0" ];then
exit 0
fi

dat1=`cat $1`
dat2=`cat $2`
flag=1
if [ $dat1 != $dat2 ];then
flag=0
fi
if [ $flag -eq 1];then
echo "isti se"
rm $2

code=$?
if [ $code -eq 0 ];then
echo "Brisenjeto e uspesno"
else
echo "Brisenjeto ne e uspesno"
fi
else
echo "Ne se isti"
fi

============================================================================================================================================================
